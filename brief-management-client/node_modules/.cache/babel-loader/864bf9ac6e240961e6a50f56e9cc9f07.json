{"ast":null,"code":"import { createAsyncThunk, createSelector, createSlice } from \"@reduxjs/toolkit\";\nconst initialState = {\n  nodes: [],\n  checkoutState: \"LOADING\",\n  errorMessage: \"\"\n};\nexport const getBriefs = createAsyncThunk(\"briefs/get\", async () => {\n  const response = await fetch(\"http://localhost:4000/briefs\");\n  return await response.json();\n});\nexport const addBrief = createAsyncThunk(\"briefs/add\", async payload => {\n  const resp = await fetch(\"http://localhost:4000/briefs\", {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify({\n      id: payload.id,\n      title: payload.title,\n      comment: payload.comment,\n      productId: payload.productId\n    })\n  });\n\n  if (resp.ok) {\n    const brief = await resp.json();\n    return {\n      brief\n    };\n  }\n});\nconst briefsSlice = createSlice({\n  name: \"brieves\",\n  initialState,\n  reducers: {\n    /*  addBrief: (state, action) => {\n      const brief = {\n        id: state.nodes[state.nodes.length - 1].id++,\n        title: action.payload.title,\n        comment: action.payload.comment,\n        productId: action.payload.productId,\n      };\n      state.nodes.push(brief);\n    }, */\n  },\n  extraReducers: builder => {\n    builder.addCase(getBriefs.pending, state => {\n      state.checkoutState = \"LOADING\";\n    });\n    builder.addCase(getBriefs.fulfilled, (state, action) => {\n      state.checkoutState = \"READY\";\n      state.nodes = action.payload;\n    });\n    builder.addCase(getBriefs.rejected, (state, action) => {\n      state.checkoutState = \"ERROR\";\n      state.errorMessage = action.error.message || \"\";\n    });\n    builder.addCase(addBrief.fulfilled, (state, action) => {\n      var _action$payload;\n\n      state.nodes.push((_action$payload = action.payload) === null || _action$payload === void 0 ? void 0 : _action$payload.brief);\n    });\n  }\n}); // export const { addBrief } = briefsSlice.actions;\n\nexport default briefsSlice.reducer;\nexport const getBriefsByProductId = createSelector(state => state.briefs.nodes, (state, productId) => productId, (nodes, productId) => productId !== \"\" ? nodes.filter(node => node.productId === parseInt(productId) + 1) : nodes);","map":{"version":3,"sources":["/home/franck/brief-management/brief-management-client/src/features/briefs/briefsSlice.ts"],"names":["createAsyncThunk","createSelector","createSlice","initialState","nodes","checkoutState","errorMessage","getBriefs","response","fetch","json","addBrief","payload","resp","method","headers","body","JSON","stringify","id","title","comment","productId","ok","brief","briefsSlice","name","reducers","extraReducers","builder","addCase","pending","state","fulfilled","action","rejected","error","message","push","reducer","getBriefsByProductId","briefs","filter","node","parseInt"],"mappings":"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","sourcesContent":["import { createAsyncThunk, createSelector, createSlice } from \"@reduxjs/toolkit\";\nimport { CheckoutState } from \"../../shared/api/constant\";\nimport { RootState } from \"../../shared/store\";\n\nexport interface Brief {\n  id: number;\n  title: string;\n  comment: string;\n  productId: number;\n}\n\nexport type BriefResponse = Brief[];\n\n\nexport interface BriefState {\n  nodes: BriefResponse;\n  checkoutState: CheckoutState;\n  errorMessage: string;\n}\n\nconst initialState: BriefState = {\n  nodes: [],\n  checkoutState: \"LOADING\",\n  errorMessage: \"\",\n};\n\nexport const getBriefs = createAsyncThunk(\"briefs/get\", async () => {\n  const response = await fetch(\"http://localhost:4000/briefs\");\n  return (await response.json()) as BriefResponse;\n});\n\n\nexport const addBrief = createAsyncThunk(\n  \"briefs/add\",\n  async (payload: Brief) => {\n    const resp = await fetch(\"http://localhost:4000/briefs\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        id:payload.id,\n        title: payload.title,\n        comment: payload.comment,\n        productId: payload.productId,\n      }),\n    });\n\n    if (resp.ok) {\n      const brief = (await resp.json()) as Brief;\n      return { brief };\n    }\n  }\n);\n\nconst briefsSlice = createSlice({\n  name: \"brieves\",\n  initialState,\n  reducers: {\n    /*  addBrief: (state, action) => {\n      const brief = {\n        id: state.nodes[state.nodes.length - 1].id++,\n        title: action.payload.title,\n        comment: action.payload.comment,\n        productId: action.payload.productId,\n      };\n      state.nodes.push(brief);\n    }, */\n  },\n  extraReducers: (builder) => {\n    builder.addCase(getBriefs.pending, (state) => {\n      state.checkoutState = \"LOADING\";\n    });\n    builder.addCase(getBriefs.fulfilled, (state, action) => {\n      state.checkoutState = \"READY\";\n      state.nodes = action.payload;\n    });\n    builder.addCase(getBriefs.rejected, (state, action) => {\n      state.checkoutState = \"ERROR\";\n      state.errorMessage = action.error.message || \"\";\n    });\n    builder.addCase(addBrief.fulfilled, (state, action) => {\n      state.nodes.push(action.payload?.brief as Brief);\n    });\n  },\n});\n\n// export const { addBrief } = briefsSlice.actions;\nexport default briefsSlice.reducer;\n\n\nexport const getBriefsByProductId = createSelector(\n  (state :RootState) => state.briefs.nodes,\n  (state:RootState, productId: string) => productId,\n  (nodes , productId ) =>\n    productId !== \"\" ? nodes.filter((node) => node.productId === parseInt(productId)+1) : nodes\n)\n\n\n\n"]},"metadata":{},"sourceType":"module"}